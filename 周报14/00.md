## 完成事项

打ISCC,以及写wp

## 未完成事项及原因

## 下周待做事项

嗯...打算看看内核相关的那些东西.

## 本周学习的知识

### 1.汇编中的一点乱七八糟的东西

最近写了一道vm_pwn的题目.所以学了一点汇编相关的东西.

(结果ISCC又出了一万道vm的题...)

**mov**

嗯...说到`mov`,我之前是把它当作'='来处理.比如`mov a,b;`可以当作`a=b`.然后我就在某道题里看到了这种东西:

```assembly
call    get_1byte
mov     [rbp+var_4E], al
movsx   edx, [rbp+var_4F]	;你是?
mov     rax, [rbp+var_68]
movsxd  rdx, edx			;你又是?
...
movzx   edx, [rbp+var_53]
movzx   esi, [rbp+var_52]
mov     rax, [rbp+var_68]
movsxd  rdx, edx
...
```

好吧,让我们言归正传.

##### mov

`mov`指令,在大多数情况下的确是可以看作'='的.它的功能是对同大小操作数的值进行复制.如将8位复制到另外一个8位,将64位复制到另一个64位(如mov rsp,rbp;).不能用于不同大小操作数间的复制.但有一个(唯一一个)例外:32位操作数可以被`mov`隐式零拓展为64位.比如`mov rax,eax`,就会导致rax的高32位被清零.(如rax的值是0x022222222 11111111,那么这句语句就会先截取eax的0x11111111,然后将它零拓展(顾名思义,在前面加0)为0x00000000 11111111.导致rax的高32位被清空.

既然mov一般只能用于同大小操作数间的复制,那么不同大小操作数之间是怎么复制的呢?

当然,高向低可以用寄存器低位来实现,而低向高,就需要一开始提到的那些乱七八糟的东西了.

#### 操作数拓展指令

##### movzx

`movzx`,用于8或16位操作数的无符号数拓展.比如8$\to$16,16$\to$64等

##### mov

刚刚说了,mov本身可以用于32位操作数的无符号拓展.这里为了格式整齐所以再提一次.

##### movsx

用于对8/16位操作数进行符号拓展.

符号拓展,具体的过程是将源操作数的符号位复制到所有需要拓展的高位,实现了操作数的值不变.

##### movsxd

用于对32位操作数进行符号拓展.

大概就是这样.

## 本周自己学习过程中遇到的问题和疑问点

打比赛的时候出flag太慢,基本等到上百个解的时候我才写好脚本.对汇编不够熟悉.

## 情感、思考、观点

## 在团队的感触和建议

